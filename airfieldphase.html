<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="KFAA Phase">
    <meta name="theme-color" content="#1a1a2e">
    <title>KFAA Phase</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #e8e8e8;
            padding: 16px;
            min-height: 100vh;
            -webkit-font-smoothing: antialiased;
        }
        
        .container {
            max-width: 600px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            font-size: 28px;
            margin-bottom: 24px;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        label {
            display: block;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 8px;
            color: #aaa;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        textarea, input[type="text"] {
            width: 100%;
            background: #0f3460;
            border: 2px solid #16213e;
            border-radius: 8px;
            color: #fff;
            padding: 14px;
            font-size: 16px;
            font-family: 'Monaco', 'Courier New', monospace;
            transition: border-color 0.2s;
        }
        
        textarea:focus, input[type="text"]:focus {
            outline: none;
            border-color: #e94560;
        }
        
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        
        .segmented {
            display: flex;
            background: #0f3460;
            border-radius: 8px;
            overflow: hidden;
            border: 2px solid #16213e;
        }
        
        .segmented label {
            flex: 1;
            margin: 0;
            text-align: center;
            padding: 12px;
            cursor: pointer;
            transition: background 0.2s;
            text-transform: capitalize;
        }
        
        .segmented input[type="radio"] {
            display: none;
        }
        
        .segmented input[type="radio"]:checked + span {
            background: #e94560;
            color: #fff;
        }
        
        .segmented span {
            display: block;
            border-radius: 6px;
            padding: 8px;
        }
        
        button {
            width: 100%;
            background: linear-gradient(135deg, #e94560 0%, #c23a50 100%);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 16px;
            font-size: 18px;
            font-weight: 700;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 4px 12px rgba(233, 69, 96, 0.3);
            margin-top: 20px;
        }
        
        button:active {
            transform: scale(0.98);
        }
        
        .result {
            margin-top: 32px;
            background: #0f3460;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.4);
        }
        
        .phase-display {
            text-align: center;
            padding: 24px;
            border-radius: 12px;
            margin-bottom: 20px;
            font-size: 32px;
            font-weight: 800;
            text-shadow: 0 2px 8px rgba(0,0,0,0.5);
        }
        
        .phase-UNRESTRICTED {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }
        
        .phase-RESTRICTED {
            background: linear-gradient(135deg, #eab308 0%, #ca8a04 100%);
        }
        
        .phase-FS-VFR {
            background: linear-gradient(135deg, #eab308 0%, #ca8a04 100%);
        }
        
        .phase-VFR {
            background: linear-gradient(135deg, #f97316 0%, #ea580c 100%);
        }
        
        .phase-IFR {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }
        
        .phase-HOLD, .phase-RECALL {
            background: linear-gradient(135deg, #991b1b 0%, #7f1d1d 100%);
        }
        
        .conditions {
            background: #16213e;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .conditions h3 {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .conditions p {
            margin: 8px 0;
            font-size: 16px;
        }
        
        .checks {
            background: #16213e;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .checks h3 {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 12px;
            text-transform: uppercase;
        }
        
        .check-item {
            padding: 8px 0;
            border-bottom: 1px solid #0f3460;
        }
        
        .check-item:last-child {
            border-bottom: none;
        }
        
        .check-pass {
            color: #22c55e;
        }
        
        .check-fail {
            color: #ef4444;
        }
        
        .restrictions {
            background: #16213e;
            padding: 16px;
            border-radius: 8px;
        }
        
        .restrictions h3 {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 12px;
            text-transform: uppercase;
        }
        
        .restrictions p {
            margin: 8px 0;
            font-size: 16px;
        }
        
        .error {
            background: #7f1d1d;
            color: #fff;
            padding: 16px;
            border-radius: 8px;
            margin-top: 20px;
        }
        
        .hidden {
            display: none;
        }
        
        .runway-info {
            background: #16213e;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }
        
        .runway-info h3 {
            font-size: 14px;
            color: #aaa;
            margin-bottom: 12px;
            text-transform: uppercase;
        }
        
        .runway-info p {
            margin: 8px 0;
            font-size: 16px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>‚úàÔ∏è KFAA Phase</h1>
        
        <div class="input-group">
            <label for="metar">METAR (OEKF)</label>
            <textarea id="metar" placeholder="OEKF 310600Z 33012KT 9999 FEW080 22/10 Q1018"></textarea>
        </div>
        
        <div class="input-group">
            <label for="taf">TAF (Optional)</label>
            <textarea id="taf" placeholder="TAF OEKF 3106/3206 33015KT 9999 FEW080"></textarea>
        </div>
        
        <div class="input-group">
            <label>Bird Strike Risk</label>
            <div class="segmented">
                <label>
                    <input type="radio" name="bird" value="low" checked>
                    <span>Low</span>
                </label>
                <label>
                    <input type="radio" name="bird" value="moderate">
                    <span>Moderate</span>
                </label>
                <label>
                    <input type="radio" name="bird" value="severe">
                    <span>Severe</span>
                </label>
            </div>
        </div>
        
        <div class="input-group">
            <label for="notices">Operational Notices</label>
            <textarea id="notices" placeholder="No ATC, No Radar, etc."></textarea>
        </div>
        
        <button onclick="determinePhase()">Determine Phase</button>
        
        <div id="result" class="hidden"></div>
        <div id="error" class="hidden"></div>
        <div id="debug" style="margin-top:16px;padding:12px;background:#0a0a1a;border:1px solid #333;border-radius:8px;font-family:monospace;font-size:12px;color:#888;white-space:pre-wrap;display:none;"></div>
    </div>

    <script>
        // Debug logger ‚Äî writes to on-screen div
        const _debugLines = [];
        function dbg(msg) {
            console.log('[PHASE]', msg);
            _debugLines.push(msg);
            const el = document.getElementById('debug');
            if (el) { el.style.display = 'block'; el.textContent = _debugLines.join('\n'); }
        }
        window.onerror = function(msg, src, line, col, err) {
            dbg('GLOBAL ERROR: ' + msg + ' at line ' + line + ':' + col);
            return false;
        };
    </script>
    <script>
        // OEKF Configuration
        const OEKF_ELEVATION_FT = 2400;
        const OEKF_MAG_VAR = 4; // degrees East
        
        const RUNWAYS = [
            { id: '15L', heading: 150, reciprocal: '33R' },
            { id: '33R', heading: 330, reciprocal: '15L' },
            { id: '15R', heading: 150, reciprocal: '33L' },
            { id: '33L', heading: 330, reciprocal: '15R' }
        ];
        
        // METAR Parser
        function parseMetar(metarString) {
            const raw = metarString.trim();
            const metar = {
                raw: raw,
                icao: null,
                wind_dir: null,
                wind_speed: null,
                wind_gust: null,
                visibility_m: null,
                clouds: [],
                temp: null,
                dewpoint: null,
                qnh: null,
                cavok: false,
                nsc: false,
                has_cb: false,
                has_ts: false,
                weather: []
            };
            
            let parts = raw.split(/\s+/);
            
            // Remove METAR/SPECI prefix
            if (parts[0] === 'METAR' || parts[0] === 'SPECI') {
                parts = parts.slice(1);
            }
            
            // Split at NOSIG/TEMPO/BECMG/RMK (trend/remarks)
            const obsParts = [];
            for (let i = 0; i < parts.length; i++) {
                if (['RMK', 'NOSIG', 'TEMPO', 'BECMG'].includes(parts[i])) {
                    break;
                }
                obsParts.push(parts[i]);
            }
            
            const consumed = new Set();
            
            // ICAO (4 letters)
            for (let i = 0; i < Math.min(3, obsParts.length); i++) {
                if (obsParts[i].length === 4 && /^[A-Z]{4}$/.test(obsParts[i]) && 
                    obsParts[i] !== 'AUTO' && obsParts[i] !== 'CAVOK') {
                    metar.icao = obsParts[i];
                    consumed.add(i);
                    break;
                }
            }
            
            if (!metar.icao) metar.icao = 'OEKF';
            
            // Timestamp (DDHHmmZ)
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                if (/^\d{6}Z$/.test(obsParts[i])) {
                    consumed.add(i);
                    break;
                }
            }
            
            // AUTO/COR
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                if (obsParts[i] === 'AUTO' || obsParts[i] === 'COR') {
                    consumed.add(i);
                }
            }
            
            // Wind
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                const match = obsParts[i].match(/^(\d{3}|VRB)(\d{2,3})(G(\d{2,3}))?KT$/);
                if (match) {
                    if (match[1] === 'VRB') {
                        metar.wind_dir = null;
                    } else if (match[1] === '000') {
                        metar.wind_dir = 0;
                        metar.wind_speed = 0;
                    } else {
                        metar.wind_dir = parseInt(match[1]);
                    }
                    
                    if (match[1] !== '000') {
                        metar.wind_speed = parseInt(match[2]);
                        if (match[4]) {
                            metar.wind_gust = parseInt(match[4]);
                        }
                    }
                    consumed.add(i);
                    break;
                }
            }
            
            // Visibility
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                if (obsParts[i] === 'CAVOK') {
                    metar.cavok = true;
                    metar.visibility_m = 10000;
                    consumed.add(i);
                    break;
                } else if (/^\d{4}$/.test(obsParts[i])) {
                    const vis = parseInt(obsParts[i]);
                    metar.visibility_m = vis === 9999 ? 10000 : vis;
                    consumed.add(i);
                    break;
                }
            }
            
            // Weather phenomena
            const wxCodes = ['BR', 'FG', 'HZ', 'RA', 'SN', 'TS', 'DZ', 'SH', 'GR', 'GS', 'CB', 'TCU'];
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                const part = obsParts[i].replace(/^[+-]/, '');
                if (wxCodes.some(code => part.includes(code))) {
                    metar.weather.push(obsParts[i]);
                    if (obsParts[i].includes('TS')) metar.has_ts = true;
                    if (obsParts[i] === 'CB') metar.has_cb = true;
                    consumed.add(i);
                }
            }
            
            // Clouds
            const clearSkyCodes = ['NSC', 'SKC', 'NCD', 'CLR'];
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                if (clearSkyCodes.includes(obsParts[i])) {
                    if (obsParts[i] === 'NSC') metar.nsc = true;
                    consumed.add(i);
                    continue;
                }
                
                const match = obsParts[i].match(/^(FEW|SCT|BKN|OVC)(\d{3})(CB|TCU)?$/);
                if (match) {
                    const coverage = match[1];
                    const height_ft = parseInt(match[2]) * 100;
                    const type = match[3] || null;
                    
                    metar.clouds.push({
                        coverage: coverage,
                        height_ft: height_ft,
                        type: type
                    });
                    
                    if (type === 'CB') {
                        metar.has_cb = true;
                    }
                    consumed.add(i);
                }
            }
            
            // Temperature/Dewpoint
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                const match = obsParts[i].match(/^(M?\d{2})\/(M?\d{2})$/);
                if (match) {
                    metar.temp = parseInt(match[1].replace('M', '-'));
                    metar.dewpoint = parseInt(match[2].replace('M', '-'));
                    consumed.add(i);
                    break;
                }
            }
            
            // QNH
            for (let i = 0; i < obsParts.length; i++) {
                if (consumed.has(i)) continue;
                const match = obsParts[i].match(/^Q(\d{4})$/);
                if (match) {
                    metar.qnh = parseInt(match[1]);
                    consumed.add(i);
                    break;
                }
            }
            
            // Check for CB in weather or remarks
            if (metar.has_ts) metar.has_cb = true;
            
            return metar;
        }
        
        // Calculate wind components
        function calculateWindComponents(windDir, windSpeed, runwayHeading) {
            let angleDiff = Math.abs(windDir - runwayHeading);
            if (angleDiff > 180) angleDiff = 360 - angleDiff;
            
            const angleRad = angleDiff * Math.PI / 180;
            const crosswind = Math.abs(windSpeed * Math.sin(angleRad));
            const headwind = windSpeed * Math.cos(angleRad);
            
            return {
                crosswind: crosswind,
                headwind: headwind,
                tailwind: headwind < 0 ? Math.abs(headwind) : 0
            };
        }
        
        // Select best runway based on wind
        function selectRunway(metar) {
            if (metar.wind_dir === null || metar.wind_speed === 0) {
                return RUNWAYS[0];
            }
            
            let bestRunway = RUNWAYS[0];
            let bestDiff = 180;
            
            for (const rwy of RUNWAYS) {
                let diff = Math.abs(rwy.heading - metar.wind_dir);
                if (diff > 180) diff = 360 - diff;
                
                if (diff < bestDiff) {
                    bestDiff = diff;
                    bestRunway = rwy;
                }
            }
            
            return bestRunway;
        }
        
        // Determine phase per LOP Table 5-4
        function determinePhase() {
            _debugLines.length = 0;
            dbg('determinePhase() called');
            const metarInput = document.getElementById('metar').value.trim();
            const tafInput = document.getElementById('taf').value.trim();
            const birdLevel = document.querySelector('input[name="bird"]:checked').value;
            const noticesInput = document.getElementById('notices').value.trim();
            
            dbg('METAR input: "' + metarInput + '"');
            dbg('TAF input: "' + tafInput + '"');
            dbg('Bird: ' + birdLevel + ', Notices: "' + noticesInput + '"');
            
            const errorDiv = document.getElementById('error');
            const resultDiv = document.getElementById('result');
            
            errorDiv.className = 'hidden';
            resultDiv.className = 'hidden';
            
            if (!metarInput) {
                dbg('ERROR: no METAR input');
                errorDiv.className = 'error';
                errorDiv.innerHTML = '<strong>Error:</strong> METAR is required';
                return;
            }
            
            try {
                dbg('Parsing METAR...');
                const metar = parseMetar(metarInput);
                dbg('Parsed: wind=' + metar.wind_dir + '/' + metar.wind_speed + 'kt, vis=' + metar.visibility_m + 'm, clouds=' + JSON.stringify(metar.clouds) + ', cavok=' + metar.cavok);
                
                // Validate critical fields
                if (metar.wind_speed === null) {
                    dbg('FAIL: wind_speed is null');
                    throw new Error('Wind group not found in METAR');
                }
                if (metar.visibility_m === null && !metar.cavok) {
                    dbg('FAIL: visibility_m is null and not CAVOK');
                    throw new Error('Visibility not found in METAR');
                }
                
                dbg('Selecting runway...');
                // Select runway
                const runway = selectRunway(metar);
                dbg('Runway: ' + runway.id + ' hdg=' + runway.heading);
                
                // Calculate wind components
                const effectiveWind = metar.wind_gust || metar.wind_speed;
                let windComponents = { crosswind: 0, headwind: 0, tailwind: 0 };
                
                if (metar.wind_dir !== null) {
                    windComponents = calculateWindComponents(metar.wind_dir, effectiveWind, runway.heading);
                } else {
                    windComponents.crosswind = effectiveWind;
                }
                
                const visKm = metar.visibility_m / 1000;
                
                // Get ceiling and lowest cloud
                let ceiling = null;
                let lowestCloud = null;
                
                for (const cloud of metar.clouds) {
                    if (lowestCloud === null || cloud.height_ft < lowestCloud) {
                        lowestCloud = cloud.height_ft;
                    }
                    if ((cloud.coverage === 'BKN' || cloud.coverage === 'OVC') && 
                        (ceiling === null || cloud.height_ft < ceiling)) {
                        ceiling = cloud.height_ft;
                    }
                }
                
                // CAVOK/NSC guarantee: clear below 5000ft AGL
                const cavokGuaranteeAgl = 5000;
                let lowestCloudForPhase = lowestCloud;
                if ((metar.cavok || metar.nsc) && lowestCloud === null) {
                    lowestCloudForPhase = cavokGuaranteeAgl;
                }
                
                // Convert AMSL phase thresholds to AGL
                const unrestrictedCloudAgl = 8000 - OEKF_ELEVATION_FT;  // 5600ft AGL
                const restrictedCloudAgl = 6000 - OEKF_ELEVATION_FT;    // 3600ft AGL
                const fsVfrCloudAgl = 5000 - OEKF_ELEVATION_FT;         // 2600ft AGL
                
                let phase = null;
                let restrictions = {};
                let checks = {};
                let reasons = [];
                
                // RECALL checks
                if (effectiveWind > 35) {
                    phase = 'RECALL';
                    reasons.push(`‚ö†Ô∏è Wind exceeds limits (${effectiveWind}kt > 35kt)`);
                } else if (metar.has_cb) {
                    phase = 'RECALL';
                    reasons.push('‚ö†Ô∏è CB (cumulonimbus) present');
                }
                
                // HOLD checks
                if (!phase && metar.temp !== null && metar.temp > 50) {
                    phase = 'HOLD';
                    reasons.push(`üå°Ô∏è Temperature exceeds 50¬∞C (${metar.temp}¬∞C)`);
                } else if (!phase && windComponents.crosswind > 24) {
                    phase = 'HOLD';
                    reasons.push(`üí® Crosswind exceeds 24kt (${windComponents.crosswind.toFixed(1)}kt)`);
                }
                
                // Phase determination
                if (!phase) {
                    // UNRESTRICTED
                    const unrestrictedChecks = [];
                    unrestrictedChecks.push(['Vis ‚â• 8km', visKm >= 8]);
                    unrestrictedChecks.push([`No cloud < 8000ft AMSL (${unrestrictedCloudAgl}ft AGL)`, 
                        lowestCloudForPhase === null || lowestCloudForPhase >= unrestrictedCloudAgl]);
                    
                    let noSctBknOvc = true;
                    for (const cloud of metar.clouds) {
                        if (cloud.height_ft < unrestrictedCloudAgl) {
                            noSctBknOvc = false;
                            break;
                        }
                        if (['SCT', 'BKN', 'OVC'].includes(cloud.coverage)) {
                            noSctBknOvc = false;
                            break;
                        }
                    }
                    if ((metar.cavok || metar.nsc) && metar.clouds.length === 0 && 
                        unrestrictedCloudAgl > cavokGuaranteeAgl) {
                        noSctBknOvc = false;
                    }
                    
                    unrestrictedChecks.push(['Max FEW above 8000ft AMSL', noSctBknOvc]);
                    unrestrictedChecks.push(['Total wind ‚â§ 25kt', effectiveWind <= 25]);
                    unrestrictedChecks.push(['Crosswind ‚â§ 15kt', windComponents.crosswind <= 15]);
                    unrestrictedChecks.push(['Tailwind ‚â§ 5kt', windComponents.tailwind <= 5]);
                    
                    checks['UNRESTRICTED'] = unrestrictedChecks;
                    
                    if (unrestrictedChecks.every(c => c[1])) {
                        phase = 'UNRESTRICTED';
                        restrictions = { solo_cadets: true, first_solo: true };
                    }
                }
                
                if (!phase) {
                    // RESTRICTED
                    const restrictedChecks = [];
                    restrictedChecks.push(['Vis ‚â• 8km', visKm >= 8]);
                    restrictedChecks.push([`No cloud < 6000ft AMSL (${restrictedCloudAgl}ft AGL)`,
                        lowestCloudForPhase === null || lowestCloudForPhase >= restrictedCloudAgl]);
                    
                    let noBknOvc = true;
                    for (const cloud of metar.clouds) {
                        if (cloud.height_ft < restrictedCloudAgl) {
                            noBknOvc = false;
                            break;
                        }
                        if (['BKN', 'OVC'].includes(cloud.coverage)) {
                            noBknOvc = false;
                            break;
                        }
                    }
                    
                    restrictedChecks.push(['Max SCT above 6000ft AMSL', noBknOvc]);
                    restrictedChecks.push(['Total wind ‚â§ 25kt', effectiveWind <= 25]);
                    restrictedChecks.push(['Crosswind ‚â§ 15kt', windComponents.crosswind <= 15]);
                    restrictedChecks.push(['Tailwind ‚â§ 5kt', windComponents.tailwind <= 5]);
                    
                    checks['RESTRICTED'] = restrictedChecks;
                    
                    if (restrictedChecks.every(c => c[1])) {
                        phase = 'RESTRICTED';
                        restrictions = { solo_cadets: true, first_solo: true, solo_note: 'Post-IIC only' };
                    }
                }
                
                if (!phase) {
                    // FS VFR
                    const fsVfrChecks = [];
                    fsVfrChecks.push(['Vis ‚â• 5km', visKm >= 5]);
                    fsVfrChecks.push([`No cloud < 5000ft AMSL (${fsVfrCloudAgl}ft AGL)`,
                        lowestCloudForPhase === null || lowestCloudForPhase >= fsVfrCloudAgl]);
                    fsVfrChecks.push(['Total wind ‚â§ 25kt', effectiveWind <= 25]);
                    fsVfrChecks.push(['Crosswind ‚â§ 15kt', windComponents.crosswind <= 15]);
                    fsVfrChecks.push(['Tailwind ‚â§ 5kt', windComponents.tailwind <= 5]);
                    
                    checks['FS VFR'] = fsVfrChecks;
                    
                    if (fsVfrChecks.every(c => c[1])) {
                        phase = 'FS VFR';
                        restrictions = { solo_cadets: false, first_solo: true, solo_note: 'Not authorized' };
                    }
                }
                
                if (!phase) {
                    // VFR
                    const vfrChecks = [];
                    vfrChecks.push(['Vis ‚â• 5km', visKm >= 5]);
                    vfrChecks.push(['Ceiling ‚â• 1500ft', ceiling === null || ceiling >= 1500]);
                    vfrChecks.push(['Total wind ‚â§ 30kt', effectiveWind <= 30]);
                    vfrChecks.push(['Crosswind ‚â§ 24kt', windComponents.crosswind <= 24]);
                    vfrChecks.push(['Tailwind ‚â§ 10kt', windComponents.tailwind <= 10]);
                    
                    checks['VFR'] = vfrChecks;
                    
                    if (vfrChecks.every(c => c[1])) {
                        phase = 'VFR';
                        restrictions = { solo_cadets: false, first_solo: false };
                    }
                }
                
                if (!phase) {
                    // IFR
                    const minVisM = 1600;
                    const minCeilingFt = 500;
                    
                    const ifrChecks = [];
                    ifrChecks.push([`Vis ‚â• ${minVisM}m`, metar.visibility_m >= minVisM]);
                    ifrChecks.push([`Ceiling ‚â• ${minCeilingFt}ft`, ceiling === null || ceiling >= minCeilingFt]);
                    ifrChecks.push(['Total wind ‚â§ 30kt', effectiveWind <= 30]);
                    ifrChecks.push(['Crosswind ‚â§ 24kt', windComponents.crosswind <= 24]);
                    ifrChecks.push(['Tailwind ‚â§ 10kt', windComponents.tailwind <= 10]);
                    
                    checks['IFR'] = ifrChecks;
                    
                    if (ifrChecks.every(c => c[1])) {
                        phase = 'IFR';
                        restrictions = { solo_cadets: false, first_solo: false };
                    }
                }
                
                if (!phase) {
                    phase = 'HOLD';
                    reasons.push('Weather below IFR minimums');
                    restrictions = { solo_cadets: false, first_solo: false, note: 'Recover only - no takeoffs' };
                }
                
                // Bird strike level adjustments
                let weatherPhase = phase;
                const birdLevelUpper = birdLevel.toUpperCase();
                
                if (birdLevelUpper !== 'LOW') {
                    const soloPhases = ['UNRESTRICTED', 'RESTRICTED', 'FS VFR'];
                    if (soloPhases.includes(phase)) {
                        weatherPhase = phase;
                        phase = 'VFR';
                        restrictions = {
                            solo_cadets: false,
                            first_solo: false,
                            solo_note: `Bird activity ${birdLevelUpper} ‚Äî phase capped at VFR`
                        };
                    } else {
                        restrictions.solo_cadets = false;
                        restrictions.first_solo = false;
                    }
                }
                
                // Service impacts (LOP 5-11 Table 5-5)
                const serviceImpacts = [];
                if (noticesInput) {
                    const noticesUpper = noticesInput.toUpperCase();
                    
                    // HOLD/RECALL services
                    const holdPatterns = {
                        'ATC': /\bNO\s+ATC\b|\bATC\s+(DOWN|FAIL|U\/?S|UNAVAIL)/,
                        'SAR HELICOPTER': /\bNO\s+SAR\b|\bSAR\s+(HELICOPTER|HELO)?\s*(DOWN|FAIL|U\/?S|UNAVAIL)/,
                        'MEDICAL': /\bNO\s+(MEDICAL|DOCTOR|AMBULANCE)\b|\b(MEDICAL|DOCTOR|AMBULANCE)\s+(DOWN|FAIL|U\/?S|UNAVAIL)/,
                        'FIRE/CRASH': /\bNO\s+(FIRE|CRASH|CFR)\b|\b(FIRE|CRASH|CFR)\s+(DOWN|FAIL|U\/?S|UNAVAIL)/
                    };
                    
                    for (const [service, pattern] of Object.entries(holdPatterns)) {
                        if (pattern.test(noticesUpper)) {
                            serviceImpacts.push({
                                service: service,
                                action: 'STOP flying',
                                phaseImpact: 'HOLD/RECALL'
                            });
                            break;
                        }
                    }
                    
                    // RADAR
                    if (/\bNO\s+RADAR\b|\bRADAR\s+(FAIL|DOWN|U\/?S|UNAVAIL|PROCEDURE)|\bWITHOUT\s+RADAR\b/.test(noticesUpper)) {
                        serviceImpacts.push({
                            service: 'RADAR',
                            action: 'No solo cadets, use No Radar Procedures',
                            phaseImpact: 'VFR'
                        });
                    }
                    
                    // MoCO
                    if (/\bNO\s+MOCO\b|\bMOCO\s+(DOWN|FAIL|U\/?S|UNAVAIL|NOT)/.test(noticesUpper)) {
                        serviceImpacts.push({
                            service: 'MoCO',
                            action: 'No T-21 take-offs/landings until MoCO in position',
                            phaseImpact: null
                        });
                    }
                    
                    // RADAR COMMS
                    if (/\bNO\s+(AIR\s+TO\s+GROUND\s+)?COMMS?\s+(WITH\s+)?RADAR\b/.test(noticesUpper)) {
                        serviceImpacts.push({
                            service: 'RADAR COMMS',
                            action: 'STOP solo cadet flying, use No Radar Procedures',
                            phaseImpact: 'RECALL'
                        });
                    }
                    
                    // DVORTAC/GUARD
                    if (/\bNO\s+(DVORTAC|GUARD)\b|\b(DVORTAC|GUARD)\s+(DOWN|FAIL|U\/?S|UNAVAIL)/.test(noticesUpper)) {
                        serviceImpacts.push({
                            service: 'DVORTAC/GUARD',
                            action: 'STOP solo cadet flying in training areas',
                            phaseImpact: 'VFR'
                        });
                    }
                }
                
                // Apply service impacts
                const phaseRank = {
                    'RECALL': 6, 'HOLD/RECALL': 6, 'HOLD': 5, 'IFR': 4, 
                    'VFR': 3, 'FS VFR': 2, 'RESTRICTED': 1, 'UNRESTRICTED': 0
                };
                
                for (const impact of serviceImpacts) {
                    if (impact.phaseImpact) {
                        const impactRank = phaseRank[impact.phaseImpact] || 0;
                        const currentRank = phaseRank[phase] || 0;
                        
                        if (['HOLD', 'HOLD/RECALL', 'RECALL'].includes(impact.phaseImpact) && impactRank > currentRank) {
                            phase = impact.phaseImpact;
                            reasons.push(`‚ö†Ô∏è ${impact.service} unavailable ‚Äî ${impact.action}`);
                            restrictions = {
                                solo_cadets: false,
                                first_solo: false,
                                note: `${impact.service} unavailable`
                            };
                        } else if (impact.phaseImpact === 'VFR') {
                            const soloPhases = ['UNRESTRICTED', 'RESTRICTED', 'FS VFR'];
                            if (soloPhases.includes(phase)) {
                                phase = 'VFR';
                                restrictions = {
                                    solo_cadets: false,
                                    first_solo: false,
                                    solo_note: `${impact.service} ‚Äî ${impact.action}`
                                };
                            }
                            restrictions.solo_cadets = false;
                            restrictions.first_solo = false;
                        }
                    }
                }
                
                // Build output
                let html = '<div class="result">';
                
                // Phase display
                const phaseClass = phase.replace(/\s+/g, '-');
                html += `<div class="phase-display phase-${phaseClass}">${phase}</div>`;
                
                // Conditions
                html += '<div class="conditions">';
                html += '<h3>Conditions (OEKF)</h3>';
                
                let cloudStr = '';
                if (metar.cavok) {
                    cloudStr = 'CAVOK';
                } else if (metar.clouds.length === 0) {
                    cloudStr = metar.nsc ? 'NSC' : 'SKC';
                } else {
                    cloudStr = metar.clouds.map(c => {
                        let str = `${c.coverage}${String(c.height_ft / 100).padStart(3, '0')}`;
                        if (c.type) str += c.type;
                        return str;
                    }).join(' ');
                }
                
                let windStr = '';
                if (metar.wind_dir !== null) {
                    windStr = `${String(metar.wind_dir).padStart(3, '0')}¬∞/${metar.wind_speed}kt`;
                } else {
                    windStr = `VRB/${metar.wind_speed}kt`;
                }
                if (metar.wind_gust) {
                    windStr += ` G${metar.wind_gust}`;
                }
                
                html += `<p>Vis: ${visKm.toFixed(1)}km | Cloud: ${cloudStr}</p>`;
                html += `<p>Wind: ${windStr}</p>`;
                html += '</div>';
                
                // Runway info
                html += '<div class="runway-info">';
                html += '<h3>Runway Info</h3>';
                html += `<p>RWY ${runway.id}</p>`;
                html += `<p>‚®Ø ${windComponents.crosswind.toFixed(1)}kt | ‚Üë ${windComponents.headwind.toFixed(1)}kt`;
                if (windComponents.tailwind > 0) {
                    html += ` | ‚Üì ${windComponents.tailwind.toFixed(1)}kt`;
                }
                html += '</p></div>';
                
                // Phase checks
                if (Object.keys(checks).length > 0) {
                    html += '<div class="checks">';
                    html += `<h3>Phase Checks (${phase})</h3>`;
                    
                    const displayPhase = weatherPhase !== phase ? weatherPhase : phase;
                    if (checks[displayPhase]) {
                        for (const [checkName, passed] of checks[displayPhase]) {
                            const emoji = passed ? '‚úÖ' : '‚ùå';
                            const className = passed ? 'check-pass' : 'check-fail';
                            html += `<div class="check-item"><span class="${className}">${emoji} ${checkName}</span></div>`;
                        }
                    }
                    html += '</div>';
                }
                
                // Restrictions
                html += '<div class="restrictions">';
                html += '<h3>Restrictions</h3>';
                
                const soloEmoji = restrictions.solo_cadets ? '‚úÖ' : '‚ùå';
                const firstSoloEmoji = restrictions.first_solo ? '‚úÖ' : '‚ùå';
                
                html += `<p>Solo cadets: ${soloEmoji}`;
                if (restrictions.solo_note) {
                    html += ` (${restrictions.solo_note})`;
                }
                html += '</p>';
                html += `<p>1st Solo: ${firstSoloEmoji}</p>`;
                
                if (restrictions.note) {
                    html += `<p><strong>Note:</strong> ${restrictions.note}</p>`;
                }
                
                if (reasons.length > 0) {
                    html += '<p style="margin-top: 12px;">';
                    for (const reason of reasons) {
                        html += `‚Ä¢ ${reason}<br>`;
                    }
                    html += '</p>';
                }
                
                if (birdLevelUpper !== 'LOW') {
                    html += `<p style="margin-top: 12px;"><strong>üê¶ Bird-Strike Risk:</strong> ${birdLevelUpper}</p>`;
                    if (weatherPhase !== phase) {
                        html += `<p>Weather supports ${weatherPhase} ‚Äî capped to ${phase} (birds ${birdLevelUpper})</p>`;
                    }
                }
                
                if (serviceImpacts.length > 0) {
                    html += '<p style="margin-top: 12px;"><strong>Service Impacts:</strong></p>';
                    for (const impact of serviceImpacts) {
                        html += `<p>‚Ä¢ ${impact.service}: ${impact.action}</p>`;
                    }
                }
                
                html += '</div>';
                html += '</div>';
                
                resultDiv.innerHTML = html;
                resultDiv.className = 'result';
                
            } catch (error) {
                dbg('EXCEPTION: ' + error.message + '\n' + error.stack);
                errorDiv.className = 'error';
                errorDiv.innerHTML = `<strong>Error:</strong> ${error.message}`;
            }
        }
    </script>
</body>
</html>
